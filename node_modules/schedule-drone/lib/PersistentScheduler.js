// Generated by CoffeeScript 1.6.2
(function() {
  var PersistentScheduler, Scheduler, Store, moment, util, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  moment = require('moment');

  _ = require('underscore');

  Scheduler = require('./Scheduler');

  Store = require('./Store');

  util = require('./util');

  PersistentScheduler = (function(_super) {
    __extends(PersistentScheduler, _super);

    PersistentScheduler.prototype.runningCyclicEvents = [];

    PersistentScheduler.prototype.defaults = {
      scheduleInterval: (moment.duration(1, 'hour')).asMilliseconds(),
      startPollingForEvents: true
    };

    function PersistentScheduler(store, options) {
      this.store = store;
      this.options = options != null ? options : {};
      this.onTickEmit = __bind(this.onTickEmit, this);
      /*
          @param {Object} store - instance of Store, the persistence layer.
          @param {Object} options - constructor options
          @param {Number} [options.scheduleInterval] -  interval in ms to
                                  search for new events in the data store.
      */

      if (!(this.store instanceof Store)) {
        throw new Error('PersistentScheduler requires a Store instance');
      }
      this.options = _.extend(this.defaults, this.options);
      if (this.options.startPollingForEvents) {
        this._checkForEvents(this.options.scheduleInterval);
      }
    }

    PersistentScheduler.prototype.scheduleAndStore = function() {
      /*
          Instance method that persists an event to be scheduled.
          @see PersistentScheduler#scheduleAndStore for details
      */
      return PersistentScheduler.scheduleAndStore.apply(PersistentScheduler, [this.store].concat(__slice.call(arguments)));
    };

    PersistentScheduler.scheduleAndStore = function(store, timestamp, event, payload, callback) {
      var data,
        _this = this;

      if (payload == null) {
        payload = {};
      }
      /*
          Class method persists a scheduled event. If a callback is supplied it
          can return the cron job created.
      
          @static
          @param {Object} store - instance of Store class
          @param {String|Date} timestamp
          @param {String} event
          @param {Object} payload
          @param {Function} callback - function (err, cronJob)
      */

      if (!(store instanceof Store)) {
        throw new Error('PersistentScheduler requires a Store instance');
      }
      if (!_.isString(event)) {
        throw new Error("Expected `event` to be String. " + event + " given!");
      }
      if (!((_.isString(timestamp)) || (_.isDate(timestamp)))) {
        throw new Error("Expected `timestamp` to be either String or Date." + ("" + timestamp + " given!"));
      }
      data = {
        timestamp: timestamp,
        event: event,
        payload: payload
      };
      return store.save(data, function(err, storedEvent) {
        return callback(err);
      });
    };

    PersistentScheduler.prototype.onTickEmit = function(event, payload) {
      /*
          Method overrides onTickEvent to make sure the event is marked as
          solved then the event is actually emitted.
          @override
      */

      var _this = this;

      if ((payload != null) && _.isString(payload.__eventId)) {
        return this.store.solve(payload.__eventId, function(err) {
          if (err != null) {
            throw new util.Error(err);
          }
          delete payload.__eventId;
          return PersistentScheduler.__super__.onTickEmit.call(_this, event, payload);
        });
      } else {
        return PersistentScheduler.__super__.onTickEmit.call(this, event, payload);
      }
    };

    PersistentScheduler.prototype._checkForEvents = function(scheduleInterval) {
      /*
          Method runs every predefined interval to fetch one time events
          scheduled for the next interval and cyclic events that were not
          are new.
          @private
          @param {Number} scheduleInterval - ms upto next query for events.
      */

      var _this = this;

      this._executeCyclicEvents();
      this._executeOneTimeEvents(scheduleInterval);
      return setTimeout(function() {
        return _this._checkForEvents(scheduleInterval);
      }, scheduleInterval);
    };

    PersistentScheduler.prototype._executeCyclicEvents = function() {
      /*
          Method fetches all cron events from the store and schedules them.
          @private
      */

      var _this = this;

      return this.store.getCyclicEvents(function(err, events) {
        var event, id, payload, timestamp, _i, _len, _ref, _results;

        if (err) {
          throw new util.Error(err);
        }
        _results = [];
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          _ref = events[_i], id = _ref.id, timestamp = _ref.timestamp, event = _ref.event, payload = _ref.payload;
          if (!(!(__indexOf.call(_this.runningCyclicEvents, id) >= 0))) {
            continue;
          }
          _this.runningCyclicEvents.push(id);
          _results.push(_this.schedule(timestamp, event, payload));
        }
        return _results;
      });
    };

    PersistentScheduler.prototype._executeOneTimeEvents = function(scheduleInterval) {
      /*
          Method fetches events from the database for a given interval and
          executes them. In addition it fetches all unsolved events and
          executed them as well.
          @param {Number} scheduleInterval - the interval in ms for events
      */

      var _this = this;

      return this.store.getOneTimeEvents(scheduleInterval, function(err, oneTimeEvents) {
        if (err != null) {
          throw new util.Error(err);
        }
        return _this.store.getUnsolvedEvents(function(err, unsolvedOneTimeEvents) {
          var event, payload, timestamp, todoEvents, _i, _len, _ref, _results;

          if (err) {
            throw new util.Error(err);
          }
          todoEvents = unsolvedOneTimeEvents.concat(oneTimeEvents);
          _results = [];
          for (_i = 0, _len = todoEvents.length; _i < _len; _i++) {
            _ref = todoEvents[_i], timestamp = _ref.timestamp, event = _ref.event, payload = _ref.payload;
            _results.push(_this.schedule(timestamp, event, payload));
          }
          return _results;
        });
      });
    };

    return PersistentScheduler;

  })(Scheduler);

  module.exports = PersistentScheduler;

}).call(this);
