// Generated by CoffeeScript 1.6.2
(function() {
  var Mixed, Store, moment, mongoose, util, _;

  _ = require('underscore');

  moment = require('moment');

  mongoose = require('mongoose');

  util = require('./util');

  Mixed = mongoose.Schema.Types.Mixed;

  Store = (function() {
    var EVENTS_COLLECTION;

    EVENTS_COLLECTION = 'ScheduledEvent';

    Store.prototype.EventModel = null;

    function Store(options) {
      var _base, _base1, _ref, _ref1;

      this.options = options != null ? options : {};
      if (!((_.isObject(this.options)) && (_.isString(this.options.connectionString)))) {
        throw new util.Error('Incorrect params');
      }
      if ((_ref = (_base = this.options).eventsCollection) == null) {
        _base.eventsCollection = EVENTS_COLLECTION;
      }
      if ((_ref1 = (_base1 = this.options).options) == null) {
        _base1.options = {};
      }
      this.connection = mongoose.createConnection(this.options.connectionString, this.options.options);
      this._setupModel();
    }

    Store.prototype.closeConnection = function(callback) {
      return this.connection.close(callback);
    };

    Store.prototype._setupModel = function() {
      /*
          @private
      */

      var EventSchema;

      EventSchema = new mongoose.Schema({
        event: {
          type: String,
          required: true
        },
        timestamp: {
          type: Date,
          required: false,
          sparse: true
        },
        done: {
          type: Boolean,
          required: false,
          sparse: true,
          "default": false
        },
        cron: {
          type: String,
          required: false,
          sparse: true
        },
        payload: {
          type: Mixed,
          required: false,
          "default": {}
        }
      });
      EventSchema.methods.publish = function() {
        var event;

        return event = {
          id: this.id,
          event: this.event,
          timestamp: this.timestamp || this.cron,
          payload: this.payload
        };
      };
      return this.EventModel = this.connection.model(this.options.eventsCollection, EventSchema);
    };

    Store.prototype.getOneTimeEvents = function(interval, callback) {
      /*
          @return {Array} all one-time events from now upto now+interval.
          @param {Number} interval - poll interval once every interval ms.
          @param {Function} callback - function (err, events)
      */

      var end, start;

      if (!((_.isNumber(interval)) && (_.isFunction(callback)))) {
        throw new util.Error("Bad params for getOneTimeEvents()", interval, callback);
      }
      start = moment().toDate();
      end = moment().add(interval).toDate();
      return this.EventModel.find().where('timestamp').exists(true).where('cron').exists(false).where('done').equals(false).where('timestamp').gte(start).lte(end).exec(function(err, events) {
        var formatedEvents;

        if (err != null) {
          return callback(err);
        }
        if (!((events != null) && _.isArray(events))) {
          return callback(null, []);
        }
        formatedEvents = events.map(function(event) {
          return event.publish();
        });
        return callback(null, formatedEvents);
      });
    };

    Store.prototype.getUnsolvedEvents = function(callback) {
      /*
          @return {Array} all unfinished one-time events.
          @param {Function} callback - function (err, events)
      */

      var now;

      if (!_.isFunction(callback)) {
        throw new util.Error('Bad params for getUnsolvedEvents()');
      }
      now = moment().toDate();
      return this.EventModel.find().where('timestamp').exists(true).where('cron').exists(false).where('done').equals(false).where('timestamp').lte(now).exec(function(err, events) {
        var formatedEvents;

        if (err != null) {
          return callback(err);
        }
        if (!((events != null) && _.isArray(events))) {
          return callback(null, []);
        }
        formatedEvents = events.map(function(event) {
          return event.publish();
        });
        return callback(null, formatedEvents);
      });
    };

    Store.prototype.getCyclicEvents = function(callback) {
      /*
          @return {Array} all cron events registered.
          @param {Function} callback - function (err, events)
      */
      if (!_.isFunction(callback)) {
        throw new util.Error('Bad params for getCyclicEvents()');
      }
      return this.EventModel.find().where('timestamp').exists(false).where('cron').exists(true).exec(function(err, events) {
        var formatedEvents;

        if (err != null) {
          return callback(err);
        }
        if (!((events != null) && _.isArray(events))) {
          return callback(null, []);
        }
        formatedEvents = events.map(function(event) {
          return event.publish();
        });
        return callback(null, formatedEvents);
      });
    };

    Store.prototype.save = function(event, callback) {
      /*
          Stores an event in the persistence layer.
          @param {Object} event - the event data to be stored
          @param {String|Date} event.timestamp - either a cron string or Date
          @param {String} event.event - the event's name
          @param {Object} event.payload - data attached to the event
          @return {Object} the saved object
      */

      var storedEvent;

      if (!((_.isObject(event)) && (_.isString(event.event)) && ((_.isString(event.timestamp)) || (_.isDate(event.timestamp))))) {
        throw new util.Error('Invalid event params for storage');
      }
      storedEvent = new this.EventModel({
        event: event.event,
        timestamp: _.isDate(event.timestamp) ? event.timestamp : void 0,
        cron: _.isString(event.timestamp) ? event.timestamp : void 0,
        payload: event.payload
      });
      return storedEvent.save(function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null, storedEvent.publish());
      });
    };

    Store.prototype.solve = function(eventId, callback) {
      /*
          Marks a one-time event as solved in the persistence layer.
          @return {Boolean} whether the event was removed or not.
      */
      return this.EventModel.findOneAndUpdate({
        _id: eventId
      }, {
        done: true
      }, function(err, event) {
        if (err != null) {
          return callback(err);
        }
        if (event == null) {
          err = new util.Error("Could not find event for id " + eventId);
          return callback(err);
        }
        return callback(null, event.done === true);
      });
    };

    return Store;

  })();

  module.exports = Store;

}).call(this);
